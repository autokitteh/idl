// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package langsvc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LangRunClient is the client API for LangRun service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LangRunClient interface {
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (LangRun_RunClient, error)
	CallFunction(ctx context.Context, in *CallFunctionRequest, opts ...grpc.CallOption) (LangRun_CallFunctionClient, error)
	RunGet(ctx context.Context, in *RunGetRequest, opts ...grpc.CallOption) (*RunGetResponse, error)
	RunCallReturn(ctx context.Context, in *RunCallReturnRequest, opts ...grpc.CallOption) (*RunCallReturnResponse, error)
	RunLoadReturn(ctx context.Context, in *RunLoadReturnRequest, opts ...grpc.CallOption) (*RunLoadReturnResponse, error)
	RunCancel(ctx context.Context, in *RunCancelRequest, opts ...grpc.CallOption) (*RunCancelResponse, error)
	ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error)
	RunDiscard(ctx context.Context, in *RunDiscardRequest, opts ...grpc.CallOption) (*RunDiscardResponse, error)
}

type langRunClient struct {
	cc grpc.ClientConnInterface
}

func NewLangRunClient(cc grpc.ClientConnInterface) LangRunClient {
	return &langRunClient{cc}
}

func (c *langRunClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (LangRun_RunClient, error) {
	stream, err := c.cc.NewStream(ctx, &LangRun_ServiceDesc.Streams[0], "/autokitteh.langsvc.LangRun/Run", opts...)
	if err != nil {
		return nil, err
	}
	x := &langRunRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LangRun_RunClient interface {
	Recv() (*RunUpdate, error)
	grpc.ClientStream
}

type langRunRunClient struct {
	grpc.ClientStream
}

func (x *langRunRunClient) Recv() (*RunUpdate, error) {
	m := new(RunUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *langRunClient) CallFunction(ctx context.Context, in *CallFunctionRequest, opts ...grpc.CallOption) (LangRun_CallFunctionClient, error) {
	stream, err := c.cc.NewStream(ctx, &LangRun_ServiceDesc.Streams[1], "/autokitteh.langsvc.LangRun/CallFunction", opts...)
	if err != nil {
		return nil, err
	}
	x := &langRunCallFunctionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LangRun_CallFunctionClient interface {
	Recv() (*RunUpdate, error)
	grpc.ClientStream
}

type langRunCallFunctionClient struct {
	grpc.ClientStream
}

func (x *langRunCallFunctionClient) Recv() (*RunUpdate, error) {
	m := new(RunUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *langRunClient) RunGet(ctx context.Context, in *RunGetRequest, opts ...grpc.CallOption) (*RunGetResponse, error) {
	out := new(RunGetResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/RunGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langRunClient) RunCallReturn(ctx context.Context, in *RunCallReturnRequest, opts ...grpc.CallOption) (*RunCallReturnResponse, error) {
	out := new(RunCallReturnResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/RunCallReturn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langRunClient) RunLoadReturn(ctx context.Context, in *RunLoadReturnRequest, opts ...grpc.CallOption) (*RunLoadReturnResponse, error) {
	out := new(RunLoadReturnResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/RunLoadReturn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langRunClient) RunCancel(ctx context.Context, in *RunCancelRequest, opts ...grpc.CallOption) (*RunCancelResponse, error) {
	out := new(RunCancelResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/RunCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langRunClient) ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error) {
	out := new(ListRunsResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/ListRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langRunClient) RunDiscard(ctx context.Context, in *RunDiscardRequest, opts ...grpc.CallOption) (*RunDiscardResponse, error) {
	out := new(RunDiscardResponse)
	err := c.cc.Invoke(ctx, "/autokitteh.langsvc.LangRun/RunDiscard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LangRunServer is the server API for LangRun service.
// All implementations must embed UnimplementedLangRunServer
// for forward compatibility
type LangRunServer interface {
	Run(*RunRequest, LangRun_RunServer) error
	CallFunction(*CallFunctionRequest, LangRun_CallFunctionServer) error
	RunGet(context.Context, *RunGetRequest) (*RunGetResponse, error)
	RunCallReturn(context.Context, *RunCallReturnRequest) (*RunCallReturnResponse, error)
	RunLoadReturn(context.Context, *RunLoadReturnRequest) (*RunLoadReturnResponse, error)
	RunCancel(context.Context, *RunCancelRequest) (*RunCancelResponse, error)
	ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error)
	RunDiscard(context.Context, *RunDiscardRequest) (*RunDiscardResponse, error)
	mustEmbedUnimplementedLangRunServer()
}

// UnimplementedLangRunServer must be embedded to have forward compatible implementations.
type UnimplementedLangRunServer struct {
}

func (UnimplementedLangRunServer) Run(*RunRequest, LangRun_RunServer) error {
	return status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedLangRunServer) CallFunction(*CallFunctionRequest, LangRun_CallFunctionServer) error {
	return status.Errorf(codes.Unimplemented, "method CallFunction not implemented")
}
func (UnimplementedLangRunServer) RunGet(context.Context, *RunGetRequest) (*RunGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunGet not implemented")
}
func (UnimplementedLangRunServer) RunCallReturn(context.Context, *RunCallReturnRequest) (*RunCallReturnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCallReturn not implemented")
}
func (UnimplementedLangRunServer) RunLoadReturn(context.Context, *RunLoadReturnRequest) (*RunLoadReturnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLoadReturn not implemented")
}
func (UnimplementedLangRunServer) RunCancel(context.Context, *RunCancelRequest) (*RunCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCancel not implemented")
}
func (UnimplementedLangRunServer) ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuns not implemented")
}
func (UnimplementedLangRunServer) RunDiscard(context.Context, *RunDiscardRequest) (*RunDiscardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDiscard not implemented")
}
func (UnimplementedLangRunServer) mustEmbedUnimplementedLangRunServer() {}

// UnsafeLangRunServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LangRunServer will
// result in compilation errors.
type UnsafeLangRunServer interface {
	mustEmbedUnimplementedLangRunServer()
}

func RegisterLangRunServer(s grpc.ServiceRegistrar, srv LangRunServer) {
	s.RegisterService(&LangRun_ServiceDesc, srv)
}

func _LangRun_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LangRunServer).Run(m, &langRunRunServer{stream})
}

type LangRun_RunServer interface {
	Send(*RunUpdate) error
	grpc.ServerStream
}

type langRunRunServer struct {
	grpc.ServerStream
}

func (x *langRunRunServer) Send(m *RunUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _LangRun_CallFunction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CallFunctionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LangRunServer).CallFunction(m, &langRunCallFunctionServer{stream})
}

type LangRun_CallFunctionServer interface {
	Send(*RunUpdate) error
	grpc.ServerStream
}

type langRunCallFunctionServer struct {
	grpc.ServerStream
}

func (x *langRunCallFunctionServer) Send(m *RunUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _LangRun_RunGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).RunGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/RunGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).RunGet(ctx, req.(*RunGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LangRun_RunCallReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCallReturnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).RunCallReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/RunCallReturn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).RunCallReturn(ctx, req.(*RunCallReturnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LangRun_RunLoadReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunLoadReturnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).RunLoadReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/RunLoadReturn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).RunLoadReturn(ctx, req.(*RunLoadReturnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LangRun_RunCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).RunCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/RunCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).RunCancel(ctx, req.(*RunCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LangRun_ListRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).ListRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/ListRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).ListRuns(ctx, req.(*ListRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LangRun_RunDiscard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDiscardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangRunServer).RunDiscard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autokitteh.langsvc.LangRun/RunDiscard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangRunServer).RunDiscard(ctx, req.(*RunDiscardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LangRun_ServiceDesc is the grpc.ServiceDesc for LangRun service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LangRun_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "autokitteh.langsvc.LangRun",
	HandlerType: (*LangRunServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunGet",
			Handler:    _LangRun_RunGet_Handler,
		},
		{
			MethodName: "RunCallReturn",
			Handler:    _LangRun_RunCallReturn_Handler,
		},
		{
			MethodName: "RunLoadReturn",
			Handler:    _LangRun_RunLoadReturn_Handler,
		},
		{
			MethodName: "RunCancel",
			Handler:    _LangRun_RunCancel_Handler,
		},
		{
			MethodName: "ListRuns",
			Handler:    _LangRun_ListRuns_Handler,
		},
		{
			MethodName: "RunDiscard",
			Handler:    _LangRun_RunDiscard_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _LangRun_Run_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CallFunction",
			Handler:       _LangRun_CallFunction_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "langsvc/langrunsvc.proto",
}
